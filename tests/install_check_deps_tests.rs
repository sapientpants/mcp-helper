use anyhow::Result;
use mcp_helper::deps::{
    Dependency, DependencyCheck, DependencyChecker, DependencyStatus, InstallInstructions,
};
use mcp_helper::install::InstallCommand;
use mcp_helper::server::{ConfigField, McpServer, ServerMetadata};
use mcp_helper::McpError;
use std::collections::HashMap;

// Mock dependency checker for testing version mismatch
#[allow(dead_code)]
struct VersionMismatchChecker {
    has_instructions: bool,
}

impl DependencyChecker for VersionMismatchChecker {
    fn check(&self) -> anyhow::Result<DependencyCheck> {
        Ok(DependencyCheck {
            dependency: Dependency::NodeJs {
                min_version: Some("18.0.0".to_string()),
            },
            status: DependencyStatus::VersionMismatch {
                installed: "16.0.0".to_string(),
                required: "18.0.0".to_string(),
            },
            install_instructions: if self.has_instructions {
                Some(InstallInstructions {
                    windows: vec![],
                    macos: vec![],
                    linux: vec![],
                })
            } else {
                None
            },
        })
    }
}

// Mock server that uses the version mismatch checker
#[allow(dead_code)]
struct TestServer {
    metadata: ServerMetadata,
    checker: Box<dyn DependencyChecker>,
}

impl McpServer for TestServer {
    fn metadata(&self) -> &ServerMetadata {
        &self.metadata
    }

    fn validate_config(&self, _config: &HashMap<String, String>) -> Result<()> {
        Ok(())
    }

    fn generate_command(&self) -> Result<(String, Vec<String>)> {
        Ok(("test".to_string(), vec![]))
    }

    fn dependency(&self) -> Box<dyn DependencyChecker> {
        Box::new(VersionMismatchChecker {
            has_instructions: true,
        })
    }
}

#[test]
fn test_version_mismatch_with_instructions() {
    // We can't directly test check_dependencies because it's private
    // But we can test the public handle_missing_dependency method
    let _check = DependencyCheck {
        dependency: Dependency::NodeJs {
            min_version: Some("18.0.0".to_string()),
        },
        status: DependencyStatus::VersionMismatch {
            installed: "16.0.0".to_string(),
            required: "18.0.0".to_string(),
        },
        install_instructions: Some(InstallInstructions {
            windows: vec![],
            macos: vec![],
            linux: vec![],
        }),
    };

    // This should test the version mismatch error path
    // But since handle_missing_dependency doesn't handle version mismatch, we need a different approach
}

#[test]
fn test_get_dependency_name_all_variants() {
    let deps = vec![
        (Dependency::NodeJs { min_version: None }, "Node.js"),
        (
            Dependency::NodeJs {
                min_version: Some("18.0.0".to_string()),
            },
            "Node.js",
        ),
        (Dependency::Python { min_version: None }, "Python"),
        (
            Dependency::Python {
                min_version: Some("3.9".to_string()),
            },
            "Python",
        ),
        (Dependency::Docker, "Docker"),
        (Dependency::Git, "Git"),
    ];

    for (dep, expected_name) in deps {
        let name = InstallCommand::get_dependency_name(&dep);
        assert_eq!(name, expected_name);
    }
}

#[test]
fn test_handle_installed_dependency_edge_cases() {
    // Test with empty version
    let result = InstallCommand::handle_installed_dependency("Node.js", &Some("".to_string()));
    assert!(result.is_ok());

    // Test with very long version
    let long_version = "1.2.3-beta.4+build.5678.really.long.version.string";
    let result =
        InstallCommand::handle_installed_dependency("Python", &Some(long_version.to_string()));
    assert!(result.is_ok());
}

#[test]
fn test_build_field_prompt_all_combinations() {
    use mcp_helper::server::ConfigFieldType;

    let test_cases = vec![
        // (name, description, is_required, expected)
        (
            "api_key",
            Some("API Key for service"),
            true,
            "API Key for service",
        ),
        (
            "api_key",
            Some("API Key for service"),
            false,
            "API Key for service (optional)",
        ),
        ("token", None, true, "token"),
        ("token", None, false, "token (optional)"),
        ("", Some("Empty name field"), true, "Empty name field"),
        ("field", Some(""), true, ""),
        (
            "very_long_field_name_that_should_still_work",
            None,
            false,
            "very_long_field_name_that_should_still_work (optional)",
        ),
    ];

    for (name, desc, is_required, expected) in test_cases {
        let field = ConfigField {
            name: name.to_string(),
            field_type: ConfigFieldType::String,
            description: desc.map(|s| s.to_string()),
            default: None,
        };

        let prompt = InstallCommand::build_field_prompt(&field, is_required);
        assert_eq!(
            prompt, expected,
            "Failed for name: {name}, desc: {desc:?}, required: {is_required}"
        );
    }
}

#[test]
fn test_create_server_docker_not_supported() {
    let cmd = InstallCommand::new(false);

    // Test Docker server type (not yet supported)
    let result = cmd.execute("docker:redis:latest");
    assert!(result.is_err());

    if let Err(McpError::ServerError { message, .. }) = result {
        assert!(message.contains("not yet supported"));
    } else {
        panic!("Expected ServerError for unsupported Docker server");
    }
}

#[test]
fn test_create_server_local_not_supported() {
    let cmd = InstallCommand::new(false);

    // Test local file server type (not yet supported)
    let result = cmd.execute("./local/server/path");
    assert!(result.is_err());
}

#[test]
fn test_execute_with_special_characters() {
    let cmd = InstallCommand::new(false);

    // Test server name with special characters
    let result = cmd.execute("@test/server-name_with.special~chars@1.0.0");
    assert!(result.is_err());
}

#[test]
fn test_install_command_verbose_mode() {
    let cmd = InstallCommand::new(true);
    // The verbose flag should be set
    // We can't directly check it, but running with verbose shouldn't panic
    let _ = cmd.execute("test-package");
}

#[test]
fn test_empty_server_name_variations() {
    let cmd = InstallCommand::new(false);

    // Test various empty/whitespace server names
    let empty_names = vec!["", " ", "  ", "\t", "\n", " \t\n "];

    for name in empty_names {
        let result = cmd.execute(name);
        assert!(
            result.is_err(),
            "Expected error for empty server name: '{name}'"
        );
    }
}
